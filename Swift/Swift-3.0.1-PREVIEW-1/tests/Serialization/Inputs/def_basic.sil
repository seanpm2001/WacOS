sil_stage raw // CHECK: sil_stage raw

import Builtin
import Swift

// Test SIL Global variable.
// TODO: Handling of global variables has changed: the globalinit_* symbols are now mangled.
// The test passes but probably it is not testing global variables as it should.

// CHECK-NOT: sil_global private @globalinit_token0 : $Builtin.Word
sil_global private @globalinit_token0 : $Builtin.Word

// CHECK-NOT: sil_global public @public_global : $Builtin.Word
sil_global public @public_global : $Builtin.Word

sil_global @staticProp : $Int
sil [fragile] @globalinit_func0 : $@convention(thin) () -> ()

// We should not serialize this.
// CHECK-NOT: sil public_external @_TFV18lazy_global_access4Type10staticPropSia : $@convention(thin) () -> Builtin.RawPointer {
sil @_TFV18lazy_global_access4Type10staticPropSia : $@convention(thin) () -> Builtin.RawPointer {
bb0:
  %1 = global_addr @globalinit_token0 : $*Builtin.Word
  %2 = address_to_pointer %1 : $*Builtin.Word to $Builtin.RawPointer
  %3 = function_ref @globalinit_func0 : $@convention(thin) () -> ()
  %5 = builtin "once"(%2 : $Builtin.RawPointer, %3 : $@convention(thin) () -> ()) : $()
  %6 = global_addr @staticProp : $*Int
  %7 = address_to_pointer %6 : $*Int to $Builtin.RawPointer
  return %7 : $Builtin.RawPointer
}

// This references a public global so we *SHOULD* deserialize this.
// CHECK-LABEL: sil public_external [fragile] @_TFV18lazy_global_access4Type10staticPropSia_public : $@convention(thin) () -> Builtin.RawPointer {
sil [fragile] @_TFV18lazy_global_access4Type10staticPropSia_public : $@convention(thin) () -> Builtin.RawPointer {
bb0:
  // CHECK: alloc_global @public_global
  alloc_global @public_global
  // CHECK: global_addr @public_global : $*Builtin.Word
  %1 = global_addr @public_global : $*Builtin.Word
  // CHECK: unchecked_addr_cast {{%.*}} : $*Builtin.Word to $*Builtin.RawPointer
  %a = unchecked_addr_cast %1 : $*Builtin.Word to $*Builtin.RawPointer
  %2 = address_to_pointer %a : $*Builtin.RawPointer to $Builtin.RawPointer
  %3 = function_ref @globalinit_func0 : $@convention(thin) () -> ()
  // CHECK: {{%.*}} = builtin "once"({{%.*}} : $Builtin.RawPointer, {{%.*}} : $@convention(thin) () -> ()) : $()
  %5 = builtin "once"(%2 : $Builtin.RawPointer, %3 : $@convention(thin) () -> ()) : $()
  %6 = global_addr @staticProp : $*Int
  %7 = address_to_pointer %6 : $*Int to $Builtin.RawPointer
  return %7 : $Builtin.RawPointer
}

// Type references

// Some cyclic type references between SIL function bodies.
class Class1 { 
  var a : Class2 
  init()
}
class Class2 { 
  var b : Class1 
  init()
}

// Instructions

// CHECK-LABEL: sil public_external [fragile] @test1 : $@convention(thin) () -> ()
sil [fragile] @test1 : $@convention(thin) () -> () {
bb0:                                  // CHECK: bb0:
  %0 = tuple ()                       // CHECK:   %0 = tuple ()
  br bb1                              // CHECK:   br bb1
bb1:
  %b = alloc_box $Int
  %c = integer_literal $Builtin.Word, 1
  return %0 : $()                     // CHECK:   return %0 : $()
}

// Forward referenced values.
// CHECK-LABEL: sil public_external [fragile] @test2 : $@convention(thin) (Int) -> ()
sil [fragile] @test2 : $@convention(thin) (Int) -> () {
  // CHECK: bb1:
  // CHECK: %[[VAL:[0-9]+]] = tuple ()
  // CHECK: br bb2
  // CHECK: bb2:
  // CHECK: return %[[VAL]] : $()
bb0(%0 : $Int):
  br bb2
bb1:
  // Forward reference MRVs.
  store %0 to %7 : $*Int
  strong_release %6 : $@box Int

  return %5 : $()
bb2:
  %5 = tuple ()
  %6 = alloc_box $Int
  %7 = project_box %6 : $@box Int
  br bb1
}

// CHECK-LABEL: @named_tuple : $@convention(thin) () -> (Builtin.Word, Builtin.Word)
sil [fragile] @named_tuple : $@convention(thin) () -> (Builtin.Word, Builtin.Word) {
  %0 = integer_literal $Builtin.Word, 42
  // CHECK: integer_literal $Builtin.Word, 42
  %9 = tuple $(Builtin.Word, Builtin.Word) (%0, %0)
  %10 = return %9 : $(Builtin.Word, Builtin.Word)
}

sil [fragile] @return_int : $@convention(thin) (Int) -> Int { // CHECK-LABEL: $@convention(thin) (Int) -> Int {
bb0(%0 : $Int):                          // CHECK: bb0(%0 : $Int):
  // CHECK: alloc_stack $Int
  // CHECK: store
  %1 = alloc_stack $Int
  store %0 to %1 : $*Int
  %3 = load %1 : $*Int
  dealloc_stack %1 : $*Int
  return %3 : $Int                       // CHECK: return {{.*}} : $Int
}

// CHECK-LABEL: @call_fn_pointer : $@convention(thin) (() -> Int) -> Int {
sil [fragile] @call_fn_pointer : $@convention(thin) (() -> Int) -> Int {
bb0(%0 : $() -> Int):
  %1 = alloc_stack $() -> Int
  store %0 to %1 : $*() -> Int
  %3 = load %1 : $*() -> Int
  strong_retain %3 : $() -> Int
  // CHECK: strong_retain %{{.*}} : $() -> Int
  %5 = apply %3() : $() -> Int
  // CHECK: apply %{{.*}}() : $() -> Int
  %6 = load %1 : $*() -> Int
  strong_release %3 : $() -> Int
  // CHECK: strong_release {{.*}} : $() -> Int
  dealloc_stack %1 : $*() -> Int
  return %5 : $Int                       // CHECK: return %{{.*}} : $Int
}

sil [fragile] @return_constant : $@convention(thin) () -> Int {  // CHECK-LABEL: @return_constant
bb0:                                         // CHECK: bb0:
  // CHECK: function_ref @_TFSi25convertFromIntegerLiteralfMSiFT3valBi64__Si : $@convention(thin) (Builtin.Word, @thin Int.Type) -> Int
  %1 = function_ref @_TFSi25convertFromIntegerLiteralfMSiFT3valBi64__Si : $@convention(thin) (Builtin.Word, @thin Int.Type) -> Int

  // CHECK: metatype $@thin Int.Type
  %2 = metatype $@thin Int.Type

  // CHECK: integer_literal $Builtin.Word, 1
  %3 = integer_literal $Builtin.Word, 1

  // CHECK: apply
  %4 = apply %1(%3, %2) : $@convention(thin) (Builtin.Word, @thin Int.Type) -> Int
  // CHECK: return
  %5 = return %4 : $Int
}

sil [fragile] @_TFSi25convertFromIntegerLiteralfMSiFT3valBi64__Si : $@convention(thin) (Builtin.Word, @thin Int.Type) -> Int

// Parse SIL generated from the following swift program:
// func x(_ a : Bool) -> Int { if a { return 4 } else {return 5} }
sil [fragile] @_TFSb13getLogicValuefRSbFT_Bi1_ : $@convention(method) (@inout Bool) -> Builtin.Int1
sil [fragile] @_TFSi33_convertFromBuiltinIntegerLiteralfMSiFT3valBi128__Si : $@convention(thin) (Builtin.Int128, @thin Int.Type) -> Int


protocol P {
  func doIt()
}

// CHECK-LABEL: @existentials : $@convention(thin) (@in P) -> () {
sil [fragile] @existentials : $@convention(thin) (@in P) -> () {
bb0(%0 : $*P):
  %1 = open_existential_addr %0 : $*P to $*@opened("01234567-89ab-cdef-0123-000000000000") P // CHECK: open_existential_addr %0

  // CHECK: witness_method ${{.*}}, #P.doIt!1
  %2 = witness_method $@opened("01234567-89ab-cdef-0123-000000000000") P, #P.doIt!1, %1 : $*@opened("01234567-89ab-cdef-0123-000000000000") P : $@convention(witness_method) <T: P> (@inout T) -> ()
  // Make sure we have the correct scope for generic parameters.
  // CHECK: witness_method $@opened("{{.*}}") P, #P.doIt!1
  %7 = witness_method $@opened("01234567-89ab-cdef-0123-000000000000") P, #P.doIt!1, %1 : $*@opened("01234567-89ab-cdef-0123-000000000000") P : $@convention(witness_method) <T: P> (@inout T) -> ()
  // CHECK: apply
  %3 = apply %2<@opened("01234567-89ab-cdef-0123-000000000000") P>(%1) : $@convention(witness_method) <T: P> (@inout T) -> ()
  %4 = tuple ()                       // CHECK: tuple ()
  %5 = destroy_addr %0 : $*P          // CHECK: destroy_addr %0 : $*P
  %6 = return %4 : $()                // CHECK: return
}


class C {
  func doIt() {}
}

class D : C {
  override func doIt() {
    super.doIt()
  }
}

// CHECK-LABEL: @classes : $@convention(thin) () -> () {
sil [fragile] @classes : $@convention(thin) () -> () {
bb0:
  // CHECK: %0 = alloc_ref $C
  %C = alloc_ref $C
  // CHECK: unchecked_ref_cast %0 : $C to $Builtin.NativeObject
  %1 = unchecked_ref_cast %C : $C to $Builtin.NativeObject
  // CHECK: unchecked_ref_cast %0 : $C to $Builtin.UnknownObject
  %O = unchecked_ref_cast %C : $C to $Builtin.UnknownObject

  // CHECK: class_method {{.*}} : $C, #C.doIt!1
  %2 = class_method %C : $C, #C.doIt!1 : (C) -> () -> (), $@convention(method) (@guaranteed C) -> ()

  // CHECK: alloc_ref $D
  %D = alloc_ref $D

  // CHECK: upcast {{.*}} : $D to $C
  %a = upcast %D : $D to $C

  // CHECK: unconditional_checked_cast {{.*}} : $C to $D
  %5 = unconditional_checked_cast %C : $C to $D
  %6 = tuple ()
  %7 = return %6 : $()
}

// Generated from:
// func archetype_member_ref<T : Runcible>(_ x: T) {
//   x.free_method()
//   var u = x.associated_method()
//   T.static_method()
// }

protocol Runcible {
  var free:Int { get }

  func free_method() -> Int
  static func static_method()
}

//sil @_TF4arch20archetype_member_refUS_8Runcible___FT1xQ__T_ : $@convention(thin) <T : Runcible> (T) -> () {
//bb0(%0 : $*T):
  //%1 = witness_method $*T, #Runcible.free_method!1 : $@cc(method) (@inout T) -> Int
  //%2 = apply %1(%0) : $@cc(method) ((), @inout T) -> Int
  //%3 = alloc_stack $@thick T.U.Type
  //%4 = witness_method $*T, #Runcible.associated_method!1 : $@cc(method) (@inout T) -> @thick T.U.Type
  //%5 = apply %4(%0) : $@cc(method) ((), @inout T) -> @thick T.U.Type
  //%6 = store %5 to %3#1 : $*@thick T.U.Type
  //%7 = metatype $@thick T.Type
  //%8 = witness_method [volatile] $*T, #Runcible.static_method!1 : $(@thick T.Type) -> ()
  //%9 = apply %8(%7) : $((), @thick T.Type) -> ()
  //%10 = dealloc_stack %3#0 : $*@thick T.U.Type
  //%11 = tuple ()
  //%12 = destroy_addr %0 : $*T
  //%13 = return %11 : $()
//}

protocol Bendable { }

// CHECK-LABEL: $@convention(thin) (@in Bendable & Runcible) -> @out Runcible
sil [fragile] @_TF4todo18erasure_from_protoFT1xPS_8RuncibleS_8Bendable__PS0__ : $@convention(thin) (@in Bendable & Runcible) -> (@out Runcible) {
bb0(%0 : $*Runcible, %1 : $*Bendable & Runcible):
  // CHECK: alloc_box
  %2 = alloc_box $Bendable & Runcible
  %2a = project_box %2 : $@box Bendable & Runcible
  // CHECK: copy_addr [take] {{.*}} to [initialization] {{.*}} : $*Bendable & Runcible
  %3 = copy_addr [take] %1 to [initialization] %2a : $*Bendable & Runcible
  // CHECK: alloc_stack
  %4 = alloc_stack $Bendable & Runcible
  // CHECK: copy_addr {{.*}} to [initialization] {{.*}} : $*Bendable & Runcible
  %5 = copy_addr %2a to [initialization] %4 : $*Bendable & Runcible
  %7 = tuple ()
  // CHECK: destroy_addr
  %8 = destroy_addr %4 : $*Bendable & Runcible
  // CHECK: dealloc_stack
  %9 = dealloc_stack %4 : $*Bendable & Runcible
  %10 = strong_release %2 : $@box Bendable & Runcible
  // CHECK: return
  %11 = return %7 : $()
}

protocol ClassBound : class {
  func classBoundMethod()
}

// CHECK-LABEL: @_TF4todo18class_bound_methodFT1xPS_10ClassBound__T_ : $@convention(thin) (@owned ClassBound) -> ()
sil [fragile] @_TF4todo18class_bound_methodFT1xPS_10ClassBound__T_ : $@convention(thin) (@owned ClassBound) -> () {
bb0(%0 : $ClassBound):
  %1 = alloc_box $ClassBound
  %1a = project_box %1 : $@box ClassBound
  %2 = store %0 to %1a : $*ClassBound
  %3 = load %1a : $*ClassBound
  %4 = strong_retain %3 : $ClassBound              // CHECK: strong_retain
  // CHECK: open_existential_ref {{%.*}} : $ClassBound to $@opened({{.*}}) ClassBound
  %5 = open_existential_ref %3 : $ClassBound to $@opened("01234567-89ab-cdef-0123-111111111111") ClassBound
  // CHECK: witness_method
  %6 = witness_method $@opened("01234567-89ab-cdef-0123-111111111111") ClassBound, #ClassBound.classBoundMethod!1, %5 : $@opened("01234567-89ab-cdef-0123-111111111111") ClassBound : $@convention(witness_method) <T: ClassBound> (T) -> ()
  %7 = apply %6<@opened("01234567-89ab-cdef-0123-111111111111") ClassBound>(%5) : $@convention(witness_method) <T: ClassBound> (T) -> ()
  %8 = tuple ()
  %9 = strong_release %1 : $@box ClassBound
  %10 = return %8 : $()
}

struct Val {
}

//sil @_TFV4todo3ValCfMS0_FT_S0_ : $@convention(thin) (@thin Val.Type) -> Val {
//bb0(%0 : $@thin Val.Type):
  //%1 = alloc_stack $Val
  //%3 = load %1#1 : $*Val
  //%4 = return %3 : $Val
//}

class Ref {
}
struct Aleph {
  var a:Ref
  var b:Val
}

// CHECK-LABEL: @_TFV6struct5AlephCfMS0_FT1aCS_3Ref1bVS_3Val_S0_ : $@convention(thin) (Ref, Val, @thin Aleph.Type) -> Aleph
sil [fragile] @_TFV6struct5AlephCfMS0_FT1aCS_3Ref1bVS_3Val_S0_ : $@convention(thin) (Ref, Val, @thin Aleph.Type) -> Aleph {
bb0(%0 : $Ref, %1 : $Val, %2 : $@thin Aleph.Type):
  // CHECK: struct $Aleph ({{%.*}} : $Ref, {{%.*}} : $Val)
  %3 = struct $Aleph (%0 : $Ref, %1 : $Val)
  %4 = return %3 : $Aleph  // CHECK: return
}

// CHECK-LABEL: @_TFV6struct5AlephCfMS0_FT_S0_ : $@convention(thin) (@thin Aleph.Type) -> Aleph
sil [fragile] @_TFV6struct5AlephCfMS0_FT_S0_ : $@convention(thin) (@thin Aleph.Type) -> Aleph {
bb0(%0 : $@thin Aleph.Type):
  %1 = tuple ()
  %2 = alloc_box $Aleph       // CHECK: alloc_box
  %2a = project_box %2 : $@box Aleph
  // CHECK: struct_element_addr {{.*}} : $*Aleph, #Aleph.a
  %5 = struct_element_addr %2a : $*Aleph, #Aleph.a
  %6 = load %5 : $*Ref
  %8 = strong_release %6 : $Ref
  %14 = load %2a : $*Aleph
  // CHECK: struct_extract {{%.*}} : $Aleph, #Aleph.a
  %15 = struct_extract %14 : $Aleph, #Aleph.a
  %16 = strong_retain %15 : $Ref
  %17 = strong_release %2 : $@box Aleph
  %18 = return %14 : $Aleph
}

enum Beth {
  case EmptyCase
  case DataCase(Int)
}

// CHECK-LABEL: @test_union_empty_case : $@convention(thin) () -> Beth {
sil [fragile] @test_union_empty_case : $@convention(thin) () -> Beth {
bb0:
  // CHECK: %0 = enum $Beth, #Beth.EmptyCase!enumelt
  %0 = enum $Beth, #Beth.EmptyCase!enumelt
  return %0 : $Beth
}

// CHECK-LABEL: @test_union_data_case : $@convention(thin) (Int) -> Beth {
sil [fragile] @test_union_data_case : $@convention(thin) Int -> Beth {
bb0(%0 : $Int):
  // CHECK: %1 = enum $Beth, #Beth.DataCase!enumelt.1, %0 : $Int
  %1 = enum $Beth, #Beth.DataCase!enumelt.1, %0 : $Int
  return %1 : $Beth
}

protocol Q {}

enum Gimel {
  case EmptyCase
  case DataCase(Q)
}

// CHECK-LABEL: @test_union_addr_empty_case : $@convention(thin) () -> @out Gimel {
sil [fragile] @test_union_addr_empty_case : $@convention(thin) () -> @out Gimel {
bb0(%0 : $*Gimel):
  // CHECK: inject_enum_addr {{%.*}} : $*Gimel, #Gimel.EmptyCase!enumelt
  inject_enum_addr %0 : $*Gimel, #Gimel.EmptyCase!enumelt
  %t = tuple ()
  return %t : $()
}

// CHECK-LABEL: @test_union_addr_data_case : $@convention(thin) (@in Q) -> @out Gimel {
sil [fragile] @test_union_addr_data_case : $@convention(thin) (@in Q) -> @out Gimel {
bb0(%0 : $*Gimel, %1 : $*Q):
  // CHECK: {{%.*}} = init_enum_data_addr {{%.*}} : $*Gimel, #Gimel.DataCase!enumelt.1
  %p = init_enum_data_addr %0 : $*Gimel, #Gimel.DataCase!enumelt.1
  copy_addr [take] %1 to [initialization] %p : $*Q
  inject_enum_addr %0 : $*Gimel, #Gimel.DataCase!enumelt.1
  %t = tuple ()
  return %t : $()
}

sil [fragile] @_TF5tuple5floatFT1xSf_T_ : $@convention(thin) (Float32) -> ()
sil [fragile] @_TF5tuple5tupleFT_TSiSf_ : $@convention(thin) () -> (Int, Float32)

// CHECK-LABEL: @_TF5tuple13tuple_elementFT1xTSiSf__T_ : $@convention(thin) (Int, Float) -> ()
sil [fragile] @_TF5tuple13tuple_elementFT1xTSiSf__T_ : $@convention(thin) (Int, Float) -> () {
bb0(%0 : $Int, %1 : $Float32):
  %2 = alloc_box $(Int, Float32)
  %2a = project_box %2 : $@box (Int, Float32)
  %3 = tuple (%0 : $Int, %1 : $Float32)
  %4 = store %3 to %2a : $*(Int, Float32)
  // CHECK: tuple_element_addr {{%.*}} : $*(Int, Float), 0
  %6 = tuple_element_addr %2a : $*(Int, Float), 0
  %7 = load %6 : $*Int
  // CHECK: tuple_element_addr {{%.*}} : $*(Int, Float), 1
  %10 = tuple_element_addr %2a : $*(Int, Float), 1
  %11 = load %10 : $*Float32
  // CHECK: function_ref
  %14 = function_ref @_TF5tuple5tupleFT_TSiSf_ : $@convention(thin) () -> (Int, Float32)
  // CHECK: apply
  %15 = apply %14() : $@convention(thin) () -> (Int, Float32)
  // CHECK: function_ref
  %19 = function_ref @_TF5tuple5floatFT1xSf_T_ : $@convention(thin) (Float32) -> ()
  // CHECK: tuple_extract {{%.*}} : $(Int, Float), 1
  %17 = tuple_extract %15 : $(Int, Float), 1
  // CHECK: apply
  %24 = apply %19(%17) : $@convention(thin) (Float32) -> ()
  %25 = tuple ()
  %26 = strong_release %2 : $@box (Int, Float32)
  %27 = return %25 : $()
}

class M {
  var member : Int
  init()
}

// CHECK-LABEL: @_TFC3ref1C3foofS0_FT1xSi_T_ : $@convention(method) (Int, @guaranteed M) -> ()
sil [fragile] @_TFC3ref1C3foofS0_FT1xSi_T_ : $@convention(method) (Int, @guaranteed M) -> () {
bb0(%0 : $Int, %1 : $M):
  %2 = alloc_box $Int
  %2a = project_box %2 : $@box Int
  %3 = store %0 to %2a : $*Int
  %4 = alloc_box $M
  %4a = project_box %4 : $@box M
  %5 = store %1 to %4a : $*M
  %6 = load %2a : $*Int
  %7 = load %4a : $*M
  %8 = strong_retain %7 : $M
  // CHECK: ref_element_addr {{%.*}} : $M, #M.member
  %9 = ref_element_addr %7 : $M, #M.member
  %10 = store %6 to %9 : $*Int
  %11 = strong_release %7 : $M
  %12 = tuple ()
  %13 = strong_release %4 : $@box M
  %14 = strong_release %2 : $@box Int
  %15 = return %12 : $()
}

class B { }
class E : B { }

// CHECK-LABEL: @_TF4null3isaFT1bCS_1B_Sb : $@convention(thin) (B) -> Builtin.Int1
sil [fragile] @_TF4null3isaFT1bCS_1B_Sb : $@convention(thin) (B) -> Builtin.Int1 {
bb0(%0 : $B):
  %1 = alloc_box $B
  %1a = project_box %1 : $@box B
  %2 = store %0 to %1a : $*B
  %3 = load %1a : $*B
  %4 = strong_retain %3 : $B
  checked_cast_br %3 : $B to $E, yes, no     // CHECK: checked_cast_br
yes(%5 : $E):
  %y = integer_literal $Builtin.Int1, 1
  br isa(%y : $Builtin.Int1)
no:
  %n = integer_literal $Builtin.Int1, 0
  br isa(%n : $Builtin.Int1)
isa(%6 : $Builtin.Int1):
  %7 = strong_release %3 : $B
  %8 = strong_release %1 : $@box B
  %9 = return %6 : $Builtin.Int1
}

sil [fragile] @_TF7literal8literalsFT_T_ : $@convention(thin) () -> ()

sil [fragile] @_TFSd31_convertFromBuiltinFloatLiteralfMSdFT5valueBf64__Sd : $@convention(thin) (Builtin.FPIEEE64, @thin Float64.Type) -> Float64
sil [fragile] @_TFSS32_convertFromBuiltinStringLiteralfMSSFT5valueBp17utf8CodeUnitCountBi64_7isASCIIBi1__SS : $@convention(thin) (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.Type) -> String

// CHECK-LABEL: @_TF5index5gep64FT1pBp1iBi64__Bp : $@convention(thin) (Builtin.RawPointer, Builtin.Word) -> Builtin.RawPointer {
sil [fragile] @_TF5index5gep64FT1pBp1iBi64__Bp : $@convention(thin) (Builtin.RawPointer, Builtin.Word) -> Builtin.RawPointer {
bb0(%0 : $Builtin.RawPointer, %1 : $Builtin.Word):
  %2 = alloc_box $Builtin.RawPointer
  %2a = project_box %2 : $@box Builtin.RawPointer
  %3 = alloc_box $Builtin.Word
  %3a = project_box %3 : $@box Builtin.Word
  %4 = store %0 to %2a : $*Builtin.RawPointer
  %5 = store %1 to %3a : $*Builtin.Word
  %7 = load %2a : $*Builtin.RawPointer
  %8 = load %3a : $*Builtin.Word
  // CHECK: index_raw_pointer {{%.*}} : $Builtin.RawPointer, {{%.*}} : $Builtin.Word
  %9 = index_raw_pointer %7 : $Builtin.RawPointer, %8 : $Builtin.Word
  %10 = strong_release %3 : $@box Builtin.Word
  %11 = strong_release %2 : $@box Builtin.RawPointer
  %12 = return %9 : $Builtin.RawPointer
}

sil_global @x : $Int
sil [fragile] @global_callee : $@convention(thin) (Builtin.Int128, @thin Int.Type) -> Int

// CHECK-LABEL: @global_code : $@convention(thin) () -> ()
sil [fragile] @global_code : $@convention(thin) () -> () {
bb0:
  // CHECK: global_addr @x : $*Int
  %0 = global_addr @x : $*Int
  %1 = function_ref @global_callee : $@convention(thin) (Builtin.Int128, @thin Int.Type) -> Int
  %2 = metatype $@thin Int.Type
  %3 = integer_literal $Builtin.Int128, 0 // CHECK: integer_literal $Builtin.Int128, 0
  %4 = apply %1(%3, %2) : $@convention(thin) (Builtin.Int128, @thin Int.Type) -> Int
  %5 = store %4 to %0 : $*Int
  %6 = tuple ()
  %7 = return %6 : $()
}

protocol SomeProtocol {
}
class SomeClass : SomeProtocol {
}
class SomeSubclass : SomeClass {}

// CHECK-LABEL: @test_class_metatype : $@convention(thin) (SomeClass, SomeSubclass) -> (@thick SomeClass.Type, @thick SomeClass.Type) {
sil [fragile] @test_class_metatype : $@convention(thin) (SomeClass, SomeSubclass) -> (@thick SomeClass.Type, @thick SomeClass.Type) {
bb0(%0 : $SomeClass, %1 : $SomeSubclass):
  %2 = alloc_box $SomeClass
  %2a = project_box %2 : $@box SomeClass
  %3 = alloc_box $SomeSubclass
  %3a = project_box %3 : $@box SomeSubclass
  %4 = store %0 to %2a : $*SomeClass
  %5 = store %1 to %3a : $*SomeSubclass
  %7 = load %2a : $*SomeClass
  // CHECK: strong_retain %{{.*}} : $SomeClass
  %8 = strong_retain %7 : $SomeClass
  // CHECK: value_metatype $@thick SomeClass.Type, {{%.*}} : $SomeClass
  %9 = value_metatype $@thick SomeClass.Type, %7 : $SomeClass
  %11 = load %3a : $*SomeSubclass
  %12 = strong_retain %11 : $SomeSubclass
  // CHECK: value_metatype $@thick SomeSubclass.Type, {{%.*}} : $SomeSubclass
  %13 = value_metatype $@thick SomeSubclass.Type, %11 : $SomeSubclass
  // CHECK: upcast %{{.*}} : $@thick SomeSubclass.Type to $@thick SomeClass.Type
  %14 = upcast %13 : $@thick SomeSubclass.Type to $@thick SomeClass.Type
  // CHECK: tuple (%{{.*}} : $@thick SomeClass.Type, %{{.*}} : $@thick SomeClass.Type)
  %15 = tuple (%9 : $@thick SomeClass.Type, %14 : $@thick SomeClass.Type)
  %16 = strong_release %11 : $SomeSubclass
  %17 = strong_release %7 : $SomeClass
  %18 = strong_release %3 : $@box SomeSubclass
  %19 = strong_release %2 : $@box SomeClass
  %20 = return %15 : $(@thick SomeClass.Type, @thick SomeClass.Type)
}

// CHECK-LABEL: @test_existential_metatype : $@convention(thin) (@in SomeProtocol) -> @thick SomeProtocol.Type {
sil [fragile] @test_existential_metatype : $@convention(thin) (@in SomeProtocol) -> @thick SomeProtocol.Type {
bb0(%0 : $*SomeProtocol):
  %1 = alloc_box $SomeProtocol
  %1a = project_box %1 : $@box SomeProtocol
  // CHECK: copy_addr [take] %0 to [initialization] %{{.*}} : $*SomeProtocol
  %2 = copy_addr [take] %0 to [initialization] %1a : $*SomeProtocol
  // CHECK: alloc_stack
  %4 = alloc_stack $SomeProtocol
  // CHECK: copy_addr %{{.*}} to [initialization] %{{.*}} : $*SomeProtocol
  %5 = copy_addr %1a to [initialization] %4 : $*SomeProtocol
  // CHECK: existential_metatype $@thick SomeProtocol.Type, {{%.*}} : $*SomeProtocol
  %6 = existential_metatype $@thick SomeProtocol.Type, %4 : $*SomeProtocol
  %7 = destroy_addr %4 : $*SomeProtocol
  %8 = dealloc_stack %4 : $*SomeProtocol
  %9 = strong_release %1 : $@box SomeProtocol
  %10 = return %6 : $@thick SomeProtocol.Type
}

// CHECK-LABEL: sil public_external [fragile] @test_unreachable
sil [fragile] @test_unreachable : $@convention(thin) () -> () {
bb0:
  unreachable
// CHECK: unreachable
}

// CHECK-LABEL: @test_unowned_retain : $@convention(thin) (SomeClass) -> () {
sil [fragile] @test_unowned_retain : $@convention(thin) (SomeClass) -> () {
bb0(%0 : $SomeClass):
  %1 = ref_to_unowned %0 : $SomeClass to $@sil_unowned SomeClass
  // CHECK: ref_to_unowned %0 : $SomeClass to $@sil_unowned SomeClass
  %2 = unowned_retain %1 : $@sil_unowned SomeClass
  // CHECK: unowned_retain %1 : $@sil_unowned SomeClass
  %3 = unowned_release %1 : $@sil_unowned SomeClass
  // CHECK: unowned_release %1 : $@sil_unowned SomeClass
  %4 = unowned_to_ref %1 : $@sil_unowned SomeClass to $SomeClass
  // CHECK: unowned_to_ref %1 : $@sil_unowned SomeClass to $SomeClass
  %5 = tuple ()
  %6 = return %5 : $()
}

// CHECK-LABEL: sil public_external [fragile] @test_basic_block_arguments
sil [fragile] @test_basic_block_arguments : $@convention(thin) (Builtin.Int1) -> Builtin.Word {
bb0(%0 : $Builtin.Int1):
  // CHECK: cond_br
  cond_br %0, bb1, bb2
bb1:
  %2 = integer_literal $Builtin.Word, 5
  br bb3(%2 : $Builtin.Word)
  //CHECK: br bb3(%2 : $Builtin.Word)
bb2:
  %4 = integer_literal $Builtin.Word, 6
  br bb3(%4 : $Builtin.Word)
  //CHECK: br bb3(%4 : $Builtin.Word)
bb3(%6 : $Builtin.Word):
  //CHECK: bb3(%6 : $Builtin.Word)
  return %6 : $Builtin.Word
}

// CHECK-LABEL: sil public_external [fragile] @test_cond_branch_basic_block_args
sil [fragile] @test_cond_branch_basic_block_args : $@convention(thin) (Int, Builtin.Int1) -> Int {
bb0(%0 : $Int, %1 : $Builtin.Int1):
  cond_br %1, bb1(%0 : $Int), bb2(%0 : $Int)
  // CHECK: cond_br %1, bb2(%0 : $Int), bb1(%0 : $Int)
bb1(%3 : $Int):
  br bb3 (%3 : $Int)
bb2(%2 : $Int):
  br bb3(%2 : $Int)
bb3(%4 : $Int):
  return %4 : $Int
}

// CHECK-LABEL: sil public_external [fragile] @test_builtin_func_ref
sil [fragile] @test_builtin_func_ref : $@convention(thin) (Builtin.Int1, Builtin.Int1) -> Builtin.Int1 {
bb0(%0 : $Builtin.Int1, %1 : $Builtin.Int1):
  %2 = alloc_box $Builtin.Int1
  %2a = project_box %2 : $@box Builtin.Int1
  %3 = alloc_box $Builtin.Int1
  %3a = project_box %3 : $@box Builtin.Int1
  store %0 to %2a : $*Builtin.Int1
  store %1 to %3a : $*Builtin.Int1
  %8 = load %2a : $*Builtin.Int1
  %9 = load %3a : $*Builtin.Int1
  // CHECK: builtin "cmp_eq_Int1"({{%.*}} : $Builtin.Int1, {{%.*}} : $Builtin.Int1) : $Builtin.Int1
  %10 = builtin "cmp_eq_Int1"(%8 : $Builtin.Int1, %9 : $Builtin.Int1) : $Builtin.Int1
  strong_release %3 : $@box Builtin.Int1
  strong_release %2 : $@box Builtin.Int1
  return %10 : $Builtin.Int1
}

// CHECK-LABEL: sil public_external [fragile] @test_dealloc_ref
sil [fragile] @test_dealloc_ref : $@convention(thin) () -> () {
bb0:
  %0 = alloc_ref $Class1
  dealloc_ref %0 : $Class1
  %2 = tuple ()
  return %2 : $()
}

// CHECK-LABEL: sil public_external [fragile] @test_dealloc_partial_ref
sil [fragile] @test_dealloc_partial_ref : $@convention(thin) () -> () {
bb0:
  %0 = alloc_ref $Class1
  %1 = metatype $@thick Class1.Type
  dealloc_partial_ref %0 : $Class1, %1 : $@thick Class1.Type
  %2 = tuple ()
  return %2 : $()
}

// CHECK-LABEL: sil public_external [fragile] @test_dealloc_box
sil [fragile] @test_dealloc_box : $@convention(thin) () -> () {
bb0:
  %0 = alloc_box $Class1
  dealloc_box %0 : $@box Class1
  %2 = tuple ()
  return %2 : $()
}

// CHECK-LABEL: sil public_external [fragile] @test_stack_flag
sil [fragile] @test_stack_flag : $@convention(thin) () -> () {
bb0:
  // CHECK: alloc_ref [stack] $Class1
  %0 = alloc_ref [stack] $Class1
  // CHECK: dealloc_ref [stack] %0 : $Class1
  dealloc_ref [stack] %0 : $Class1
  %2 = tuple ()
  return %2 : $()
}

// CHECK-LABEL: @closure_test
sil [fragile] @takes_closure : $@convention(thin) (@callee_owned () -> ()) -> ()
sil [fragile] @closure0 : $@convention(thin) (@box Int, @inout Int) -> ()

sil [fragile] @closure_test : $@convention(thin) () -> () {
bb0:
  %0 = alloc_box $Int                           // users: %10, %8, %8, %7, %4
  %0a = project_box %0 : $@box Int

  %5 = function_ref @takes_closure : $@convention(thin) (@callee_owned () -> ()) -> ()
  %6 = function_ref @closure0 : $@convention(thin) (@box Int, @inout Int) -> ()
  strong_retain %0 : $@box Int
  //%8 = partial_apply %6(%0, %0a) : $@convention(thin) (@box Int, @inout Int) -> ()
  //%9 = apply %5(%8) : $@convention(thin) (@callee_owned () -> ()) -> ()
  //strong_release %0 : $@box Int

  %11 = tuple ()
  return %11 : $()
}

protocol ClassP : class {}

enum MaybePair {
  case Neither
  case Left(Int)
}

sil [fragile] @_TF6switch1aFT_T_ : $@convention(thin) () -> ()
sil [fragile] @_TF6switch1bFT_T_ : $@convention(thin) () -> ()
sil [fragile] @_TF6switch1cFT_T_ : $@convention(thin) () -> ()

// CHECK-LABEL: sil public_external [fragile] @test_switch_union : $@convention(thin) (MaybePair) -> ()
sil [fragile] @test_switch_union : $@convention(thin) (MaybePair) -> () {
bb0(%0 : $MaybePair):
  %1 = alloc_box $MaybePair
  %1a = project_box %1 : $@box MaybePair
  store %0 to %1a : $*MaybePair
  %3 = load %1a : $*MaybePair
  %4 = tuple ()
  // CHECK: switch_enum %{{.*}} : $MaybePair, case #MaybePair.Neither!enumelt: bb{{.*}}, case #MaybePair.Left!enumelt.1: bb
  switch_enum %3 : $MaybePair, case #MaybePair.Neither!enumelt: bb1, case #MaybePair.Left!enumelt.1: bb3

bb1:
  br bb2

bb2:
  %7 = function_ref @_TF6switch1aFT_T_ : $@convention(thin) () -> ()
  %8 = apply %7() : $@convention(thin) () -> ()
  br bb5

bb3(%10 : $Int):
  // CHECK: unchecked_enum_data {{%.*}} : $MaybePair, #MaybePair.Left!enumelt.1
  %x = unchecked_enum_data %3 : $MaybePair, #MaybePair.Left!enumelt.1
  br bb4(%x : $Int)
  // CHECK: br

bb4(%y : $Int):
  %12 = function_ref @_TF6switch1bFT_T_ : $@convention(thin) () -> ()
  %13 = apply %12() : $@convention(thin) () -> ()
  br bb5                                                  // CHECK: br

bb5:
  %15 = function_ref @_TF6switch1cFT_T_ : $@convention(thin) () -> ()
  %16 = apply %15() : $@convention(thin) () -> ()
  strong_release %1 : $@box MaybePair
  %18 = tuple ()
  return %18 : $()                                        // CHECK: return
}

enum MaybeAddressOnlyPair {
  case Neither
  case Left(Q)
}

// CHECK-LABEL: sil public_external [fragile] @test_switch_union_addr : $@convention(thin) (@in MaybeAddressOnlyPair) -> ()
sil [fragile] @test_switch_union_addr : $@convention(thin) (@in MaybeAddressOnlyPair) -> () {
bb0(%0 : $*MaybeAddressOnlyPair):
  // CHECK: switch_enum_addr [[ENUM:%.*]] : $*MaybeAddressOnlyPair, case #MaybeAddressOnlyPair.Neither!enumelt: bb{{.*}}, case #MaybeAddressOnlyPair.Left!enumelt.1: bb
  switch_enum_addr %0 : $*MaybeAddressOnlyPair, case #MaybeAddressOnlyPair.Neither!enumelt: bb1, case #MaybeAddressOnlyPair.Left!enumelt.1: bb2

bb1:
  br bb3

bb2:
  // CHECK: unchecked_take_enum_data_addr [[ENUM]] : $*MaybeAddressOnlyPair, #MaybeAddressOnlyPair.Left!enumelt.1
  %q = unchecked_take_enum_data_addr %0 : $*MaybeAddressOnlyPair, #MaybeAddressOnlyPair.Left!enumelt.1
  br bb3

bb3:
  %t = tuple ()
  return %t : $()
}

// CHECK-LABEL: sil public_external [fragile] @test_switch_value : $@convention(thin) (Builtin.Word) -> ()
sil [fragile] @test_switch_value : $@convention(thin) (Builtin.Word) -> () {
bb0(%0 : $Builtin.Word):
  // CHECK: switch_value %{{.*}} : $Builtin.Word, case %1: bb2, case %2: bb1
  %1 = integer_literal $Builtin.Word, 1
  %2 = integer_literal $Builtin.Word, 2
  switch_value %0 : $Builtin.Word, case %1: bb1, case %2: bb2

bb1:
  %7 = function_ref @_TF6switch1aFT_T_ : $@convention(thin) () -> () // CHECK: function_ref
  %8 = apply %7() : $@convention(thin) () -> ()
  br bb3

bb2:
  %12 = function_ref @_TF6switch1bFT_T_ : $@convention(thin) () -> () // CHECK: function_ref
  %13 = apply %12() : $@convention(thin) () -> ()
  br bb3

bb3:
  %18 = tuple ()
  return %18 : $()                                        // CHECK: return
}

class ConcreteClass : ClassP {
}
struct Spoon : Bendable {
}

// CHECK-LABEL: sil public_external [fragile] @test_init_existential : $@convention(thin) (Spoon) -> @out Bendable
sil [fragile] @test_init_existential : $@convention(thin) (Spoon) -> @out Bendable {
bb0(%0 : $*Bendable, %1 : $Spoon):
  %2 = alloc_box $Spoon
  %2a = project_box %2 : $@box Spoon
  store %1 to %2a : $*Spoon
  // CHECK: init_existential_addr %{{.*}} : $*Bendable, $Spoon
  %4 = init_existential_addr %0 : $*Bendable, $Spoon
  // CHECK: deinit_existential_addr %{{.*}} : $*Bendable
  deinit_existential_addr %0 : $*Bendable
  %5 = load %2a : $*Spoon
  store %5 to %4 : $*Spoon
  strong_release %2 : $@box Spoon
  %8 = tuple ()
  return %8 : $()
}

// CHECK-LABEL: sil public_external [fragile] @test_existential_ref : $@convention(thin) (ConcreteClass) -> ClassP
sil [fragile] @test_existential_ref : $@convention(thin) (ConcreteClass) -> ClassP {
bb0(%0 : $ConcreteClass):
  %1 = alloc_box $ConcreteClass
  %1a = project_box %1 : $@box ConcreteClass
  store %0 to %1a : $*ConcreteClass
  %3 = load %1a : $*ConcreteClass
  strong_retain %3 : $ConcreteClass
  // CHECK: init_existential_ref %{{.*}} : $ConcreteClass : $ConcreteClass, $ClassP
  %5 = init_existential_ref %3 : $ConcreteClass : $ConcreteClass, $ClassP
  strong_release %1 : $@box ConcreteClass
  return %5 : $ClassP
}

sil [fragile] @test_assign : $@convention(thin) (Int, @inout Int) -> () {    // CHECK-LABEL: sil public_external [fragile] @test_assign
bb0(%0 : $Int, %1 : $*Int):
  assign %0 to %1 : $*Int                   // CHECK: assign
  unreachable
}

// CHECK-LABEL: sil public_external [fragile] @test_transparent : $@convention(thin) () -> () {
sil [fragile] @test_transparent : $@convention(thin) () -> () {
bb0:
  // CHECK: function_ref
  // CHECK: apply
  %0 = function_ref @classes : $@convention(thin) () -> ()
  %1 = apply %0() : $@convention(thin) () -> ()
  %2 = tuple ()
  %3 = return %2 : $()
}

// CHECK-LABEL: sil public_external [fragile] [thunk] @test_thunk : $@convention(thin) () -> () {
sil [fragile] [thunk] @test_thunk : $@convention(thin) () -> () {
bb0:
  %0 = tuple ()
  %1 = return %0 : $()
}

// CHECK-LABEL: [noinline] @noinline_callee
sil [fragile] [noinline] @noinline_callee : $@convention(thin) () -> Int {
bb0:
  %0 = function_ref @_TFSi33_convertFromBuiltinIntegerLiteralfMSiFBi2048_Si : $@convention(thin) (Builtin.Int2048, @thin Int.Type) -> Int
  %1 = metatype $@thin Int.Type
  %2 = integer_literal $Builtin.Int2048, 0 
  %3 = apply %0(%2, %1) : $@convention(thin) (Builtin.Int2048, @thin Int.Type) -> Int
  return %3 : $Int
}
// CHECK-LABEL: [always_inline] @always_inline_callee
sil [fragile] [always_inline] @always_inline_callee : $@convention(thin) () -> Int {
bb0:
  %0 = function_ref @_TFSi33_convertFromBuiltinIntegerLiteralfMSiFBi2048_Si : $@convention(thin) (Builtin.Int2048, @thin Int.Type) -> Int
  %1 = metatype $@thin Int.Type
  %2 = integer_literal $Builtin.Int2048, 0 
  %3 = apply %0(%2, %1) : $@convention(thin) (Builtin.Int2048, @thin Int.Type) -> Int
  return %3 : $Int
}
sil [fragile] [transparent] @_TFSi33_convertFromBuiltinIntegerLiteralfMSiFBi2048_Si : $@convention(thin) (Builtin.Int2048, @thin Int.Type) -> Int

// CHECK-LABEL: [_semantics "foo"] @test_semantics : $@convention(thin) () -> ()
sil [fragile] [_semantics "foo"] @test_semantics : $@convention(thin) () -> () {
bb0:
  %2 = tuple ()
  %3 = return %2 : $()
}

sil [fragile] @takes_unnamed_closure : $@convention(thin) (@callee_owned () -> Int) -> @callee_owned () -> @callee_owned () -> Int

sil [fragile] @takes_int64_float32 : $@convention(thin) (Int, Float32) -> ()

// CHECK-LABEL: sil public_external [fragile] @test_partial_apply : $@convention(thin) (Float) -> @callee_owned (Int) -> () {
sil [fragile] @test_partial_apply : $@convention(thin) Float32 -> @callee_owned Int -> () {
bb0(%0 : $Float32):
  %1 = function_ref @takes_int64_float32 : $@convention(thin) (Int, Float) -> ()
  // CHECK: partial_apply %{{.*}}(%{{.*}}) : $@convention(thin) (Int, Float) -> ()
  %2 = partial_apply %1(%0) : $@convention(thin) (Int, Float) -> ()
  %3 = return %2 : $@callee_owned Int -> ()
}

class X {
  @objc func f() { }
}

// CHECK-LABEL: sil public_external [fragile] @test_dynamic_lookup_br : $@convention(thin) (AnyObject) -> ()
sil [fragile] @test_dynamic_lookup_br : $@convention(thin) (AnyObject) -> () {
bb0(%0 : $AnyObject):
  %1 = alloc_box $AnyObject
  %1a = project_box %1 : $@box AnyObject
  store %0 to %1a : $*AnyObject
  %3 = alloc_box $Optional<() -> ()>
  %4 = load %1a : $*AnyObject
  strong_retain %4 : $AnyObject
  // CHECK: open_existential_ref %{{.*}} : $AnyObject to $@opened({{.*}}) AnyObject
  %6 = open_existential_ref %4 : $AnyObject to $@opened("01234567-89ab-cdef-0123-222222222222") AnyObject
  %7 = unchecked_ref_cast %6 : $@opened("01234567-89ab-cdef-0123-222222222222") AnyObject to $Builtin.UnknownObject
  // CHECK: dynamic_method_br %{{.*}} : $Builtin.UnknownObject, #X.f!1.foreign, bb{{.*}}, bb{{.*}}
  dynamic_method_br %7 : $Builtin.UnknownObject, #X.f!1.foreign, bb1, bb2
bb1(%z : $@convention(objc_method) (Builtin.UnknownObject) -> ()):
  br bb3

bb2:
  br bb3

bb3:
  %28 = tuple ()
  return %28 : $()
}

// CHECK-LABEL: sil public_external [fragile] @test_mark_fn_escape
sil [fragile] @test_mark_fn_escape : $@convention(thin) () -> () {
  %b = alloc_box $Int
  %ba = project_box %b : $@box Int
  %c = alloc_box $Int
  %ca = project_box %c : $@box Int

  //mark_function_escape %ba : $*Int
  //mark_function_escape %ba : $*Int, %ca : $*Int

  %28 = tuple ()
  return %28 : $()
}

// CHECK-LABEL: sil public_external [fragile] @test_copy_release_value
sil [fragile] @test_copy_release_value : $@convention(thin) (X) -> (X) {
bb0(%0 : $X):
  retain_value %0 : $X
  release_value %0 : $X
  autorelease_value %0 : $X
  return %0 : $X
  // CHECK:      retain_value [[T0:%.*]] : $X
  // CHECK-NEXT: release_value [[T0]] : $X
  // CHECK-NEXT: autorelease_value [[T0]] : $X
  // CHECK-NEXT: return [[T0]] : $X
}

// CHECK-LABEL: sil public_external [fragile] @test_set_deallocating
sil [fragile] @test_set_deallocating : $@convention(thin) (X) -> (X) {
bb0(%0 : $X):
  set_deallocating %0 : $X
  return %0 : $X
  // CHECK: set_deallocating [[T0:%.*]] : $X
  // CHECK-NEXT: return [[T0]] : $X
}

// CHECK-LABEL: sil public_external [fragile] @test_pointer_to_address
sil [fragile] @test_pointer_to_address : $@convention(thin) (Builtin.RawPointer, X) -> () {
bb0(%0 : $Builtin.RawPointer, %1 : $X):
  %2 = pointer_to_address %0 : $Builtin.RawPointer to $*X
  store %1 to %2 : $*X
  // CHECK: [[T2:%.*]] = pointer_to_address {{%.*}} : $Builtin.RawPointer to $*X
  // CHECK-NEXT: store %1 to [[T2]] : $*X
  %3 = pointer_to_address %0 : $Builtin.RawPointer to [strict] $*X
  store %1 to %3 : $*X
  // CHECK: [[T3:%.*]] = pointer_to_address {{%.*}} : $Builtin.RawPointer to [strict] $*X
  // CHECK-NEXT: store %1 to [[T3]] : $*X
  %28 = tuple ()
  return %28 : $()
}

// CHECK-LABEL: sil public_external [fragile] @test_bind_memory
sil [fragile] @test_bind_memory : $@convention(thin) (Builtin.RawPointer, Builtin.Word) -> () {
bb0(%0 : $Builtin.RawPointer, %1 : $Builtin.Word):
  bind_memory %0 : $Builtin.RawPointer, %1 : $Builtin.Word to $*X
  // CHECK: bind_memory {{%.*}} : $Builtin.RawPointer, {{%.*}} : $Builtin.Word to $*X
  %28 = tuple ()
  return %28 : $()
}

public func serialize_all() {
}

// CHECK: sil public_external [fragile] @cond_fail_test : $@convention(thin) (Builtin.Int1) -> () {
sil [fragile] @cond_fail_test : $@convention(thin) Builtin.Int1 -> () {
entry(%0 : $Builtin.Int1):
  // CHECK: cond_fail %0 : $Builtin.Int1
  cond_fail %0 : $Builtin.Int1
  %1 = tuple ()
  return %1 : $()
}

// CHECK-LABEL: sil public_external [fragile] @block_storage_type
sil [fragile] @block_storage_type : $@convention(thin) Int -> @convention(block) () -> () {
entry(%0 : $Int):
  // CHECK: [[STORAGE:%.*]] = alloc_stack $@block_storage Int
  %s = alloc_stack $@block_storage Int
  // CHECK: [[PROJECT:%.*]] = project_block_storage [[STORAGE]] : $*@block_storage Int
  %c = project_block_storage %s : $*@block_storage Int
  // CHECK: store %0 to [[PROJECT]]
  store %0 to %c : $*Int
  // CHECK: [[FUNC:%.*]] = function_ref
  %f = function_ref @block_invoke : $@convention(c) (@inout_aliasable @block_storage Int) -> ()
  // CHECK: [[BLOCK:%.*]] = init_block_storage_header [[STORAGE]] : $*@block_storage Int, invoke [[FUNC]] : $@convention(c) (@inout_aliasable @block_storage Int) -> (), type $@convention(block) () -> ()
  %b = init_block_storage_header %s : $*@block_storage Int, invoke %f : $@convention(c) (@inout_aliasable @block_storage Int) -> (), type $@convention(block) () -> ()
  // CHECK: dealloc_stack [[STORAGE]] : $*@block_storage Int
  dealloc_stack %s : $*@block_storage Int
  // CHECK: return [[BLOCK]] : $@convention(block) () -> ()
  return %b : $@convention(block) () -> ()
}

// CHECK-LABEL: sil public_external [fragile] @bitcasts : $@convention(thin) (@owned Class1) -> @owned (Class2, Int) {
// CHECK:  bb0(%0 : $Class1):
// CHECK-NEXT:    %1 = unchecked_ref_cast %0 : $Class1 to $Class2
// CHECK-NEXT:    %2 = unchecked_trivial_bit_cast %0 : $Class1 to $Int
// CHECK-NEXT:    %3 = tuple (%1 : $Class2, %2 : $Int)
// CHECK-NEXT:    return %3 : $(Class2, Int)
sil [fragile] @bitcasts : $@convention(thin) (@owned Class1) -> @owned (Class2, Int) {
entry(%0 : $Class1):
  %1 = unchecked_ref_cast %0 : $Class1 to $Class2
  %2 = unchecked_trivial_bit_cast %0 : $Class1 to $Int
  %3 = tuple (%1 : $Class2, %2 : $Int)
  return %3 : $(Class2, Int)
}

sil [fragile] @block_invoke : $@convention(c) (@inout_aliasable @block_storage Int) -> ()


// Test try_apply and throws
// rdar://20925014
// CHECK-LABEL: sil public_external [fragile] @test_try_apply : $@convention(thin) (@convention(thin) () -> @error Error) -> @error Error {
sil [fragile]  @test_try_apply : $@convention(thin) (@convention(thin) () -> @error Error) -> @error Error {
bb0(%0 : $@convention(thin) () -> @error Error):
  // CHECK: try_apply %0() : $@convention(thin) () -> @error Error, normal bb2, error bb1
  try_apply %0() : $@convention(thin) () -> @error Error, normal bb1, error bb2

bb1(%1 : $()):
  %2 = tuple ()
  return %2 : $()

bb2(%3 : $Error):
  throw %3 : $Error
}

// Test apply with the nothrow attribute
// CHECK-LABEL: sil public_external [fragile] @test_try_nothrow : $@convention(thin) (@convention(thin) () -> @error Error) -> () {
sil [fragile]  @test_try_nothrow : $@convention(thin) (@convention(thin) () -> @error Error) -> () {
bb0(%0 : $@convention(thin) () -> @error Error):
  // CHECK: apply [nothrow] %0() : $@convention(thin) () -> @error Error
  apply [nothrow] %0() : $@convention(thin) () -> @error Error
  %2 = tuple ()
  return %2 : $()
}

// CHECK-LABEL: sil public_external [fragile] @box_type : $@convention(thin) (@box Int, Int) -> () {
sil [fragile] @box_type : $@convention(thin) (@box Int, Int) -> () {
// CHECK: bb0(%0 : $@box Int, %1 : $Int):
bb0(%0 : $@box Int, %1 : $Int):
  // CHECK-NEXT: strong_retain %0 : $@box Int
  strong_retain %0 : $@box Int
  // CHECK-NEXT: %3 = project_box %0 : $@box Int
  %3 = project_box %0 : $@box Int
  // CHECK-NEXT: store %1 to %3 : $*Int
  store %1 to %3 : $*Int
  // CHECK-NEXT: strong_release %0 : $@box Int
  strong_release %0 : $@box Int
  return undef : $()
}

// rdar://15351123
// CHECK-LABEL: @test_forward_ref
sil [fragile]  @test_forward_ref : $@convention(thin) (UInt8, UInt8) -> UInt8

// CHECK-LABEL: sil public_external [fragile] @partial_apply : $@convention(thin) (@convention(thin) (Int) -> @out Int, Int) -> Int {
// CHECK: [[PA:%.*]] = partial_apply {{%.*}}({{%.*}}) : $@convention(thin) (Int) -> @out Int
// CHECK: apply [[PA]]({{%.*}}) : $@callee_owned () -> @out Int
sil [fragile] @partial_apply : $@convention(thin) (@convention(thin) (Int) -> @out Int, Int) -> Int {
entry(%f : $@convention(thin) (Int) -> @out Int, %x : $Int):
  %p = partial_apply %f(%x) : $@convention(thin) (Int) -> @out Int
  %i = alloc_stack $Int
  %z = apply %p(%i) : $@callee_owned () -> @out Int
  %y = load %i : $*Int
  dealloc_stack %i : $*Int
  return %y : $Int
}

// Make sure we serialize the body of closure even without -sil-serialize-all.
// CHECK_DECL-LABEL:  @partial_apply_with_closure
sil [fragile] [transparent] @partial_apply_with_closure : $@convention(thin) (@owned @callee_owned () -> Bool, @owned String, UnsafePointer<Int8>, Int64) -> () {
bb0(%0 : $@callee_owned () -> Bool, %1 : $String, %2 : $UnsafePointer<Int8>, %3 : $Int64):
  %17 = function_ref @closure_body : $@convention(thin) (UnsafePointer<Int8>, UnsafePointer<Int8>, Int64) -> ()
// CHECK_DECL: function_ref @closure_body
  %18 = partial_apply %17(%2, %3) : $@convention(thin) (UnsafePointer<Int8>, UnsafePointer<Int8>, Int64) -> ()
// CHECK_DECL: partial_apply
  %30 = tuple ()
  return %30 : $()
}

sil shared [fragile] @closure_body : $@convention(thin) (UnsafePointer<Int8>, UnsafePointer<Int8>, Int64) -> () {
bb0(%0 : $UnsafePointer<Int8>, %1 : $UnsafePointer<Int8>, %2 : $Int64):
  %3 = function_ref @assert_fail : $@convention(thin) (UnsafePointer<Int8>, UnsafePointer<Int8>, Int64) -> ()
  %4 = apply %3(%0, %1, %2) : $@convention(thin) (UnsafePointer<Int8>, UnsafePointer<Int8>, Int64) -> ()
  %5 = tuple ()
  return %5 : $()
}

// CHECK_DECL-LABEL: @closure_body : $@convention(thin) (UnsafePointer<Int8>, UnsafePointer<Int8>, Int64) -> () {
// CHECK_DECL: function_ref @assert_fail

sil [fragile] @assert_fail : $@convention(thin) (UnsafePointer<Int8>, UnsafePointer<Int8>, Int64) -> ()

// rdar: 15893086 
struct GenericStruct<T> {
  var x : T
}

// CHECK-LABEL: @extract_generic_struct
sil [fragile] @extract_generic_struct : $@convention(thin) GenericStruct<Int64> -> Int64 {
entry(%0 : $GenericStruct<Int64>):
  // CHECK: %1 = struct_extract %0 : $GenericStruct<Int64>, #GenericStruct.x
  %1 = struct_extract %0 : $GenericStruct<Int64>, #GenericStruct.x
  // CHECK: return %1 : $Int64
  return %1 : $Int64
}

// CHECK-LABEL: sil public_external [fragile] @select_enum : $@convention(thin) (@in Beth) -> () {
sil [fragile] @select_enum : $@convention(thin) (@in Beth) -> () {
bb0(%0 : $*Beth):
  %1 = load %0 : $*Beth
  %2 = integer_literal $Builtin.Int32, 2
  %3 = integer_literal $Builtin.Int32, 3
  // CHECK: %4 = select_enum %1 : $Beth, case #Beth.EmptyCase!enumelt: %2, case #Beth.DataCase!enumelt.1: %3 : $Builtin.Int32
  %4 = select_enum %1 : $Beth, case #Beth.EmptyCase!enumelt: %2, case #Beth.DataCase!enumelt.1: %3 : $Builtin.Int32
  // CHECK: %5 = select_enum_addr %0 : $*Beth, case #Beth.EmptyCase!enumelt: %2, case #Beth.DataCase!enumelt.1: %3 : $Builtin.Int32
  %5 = select_enum_addr %0 : $*Beth, case #Beth.EmptyCase!enumelt: %2, case #Beth.DataCase!enumelt.1: %3 : $Builtin.Int32
  // CHECK: %6 = select_enum %1 : $Beth, case #Beth.EmptyCase!enumelt: %2, default %3 : $Builtin.Int32
  %6 = select_enum %1 : $Beth, case #Beth.EmptyCase!enumelt: %2, default %3 : $Builtin.Int32
  // CHECK: %7 = select_enum_addr %0 : $*Beth, case #Beth.EmptyCase!enumelt: %2, default %3 : $Builtin.Int32
  %7 = select_enum_addr %0 : $*Beth, case #Beth.EmptyCase!enumelt: %2, default %3 : $Builtin.Int32
  return undef : $()
}

struct SomeError: Error {
  var _domain: String { get }
  var _code: Int { get }
}

// CHECK-LABEL: sil public_external [fragile] @existential_box : $@convention(thin) (SomeError) -> () {
sil [fragile] @existential_box : $@convention(thin) (SomeError) -> () {
bb0(%0 : $SomeError):
  // CHECK: %1 = alloc_existential_box $Error, $SomeError
  %1 = alloc_existential_box $Error, $SomeError
  // CHECK: %2 = project_existential_box $SomeError in %1 : $Error
  %2 = project_existential_box $SomeError in %1 : $Error
  // CHECK: store %0 to %2 : $*SomeError
  store %0 to %2 : $*SomeError
  // CHECK: %4 = open_existential_box %1 : $Error to $*[[OPENED:@opened\(".*"\)]] Error
  %4 = open_existential_box %1 : $Error to $*@opened("01234567-89AB-CDEF-0123-333333333333") Error
  // CHECK: destroy_addr %4 : $*[[OPENED]] Error
  destroy_addr %4 : $*@opened("01234567-89AB-CDEF-0123-333333333333") Error
  // CHECK: dealloc_existential_box %1 : $Error, $SomeError
  dealloc_existential_box %1 : $Error, $SomeError
  return undef : $()
}

// CHECK-LABEL: sil public_external [fragile] @bridge_object : $@convention(thin) (@owned Class1, Builtin.Word) -> () {
// CHECK:  bb0([[X:%.*]] : $Class1, [[W:%.*]] : $Builtin.Word):
// CHECK-NEXT:    [[A:%.*]] = ref_to_bridge_object [[X]] : $Class1, [[W]] : $Builtin.Word
// CHECK-NEXT:    [[B:%.*]] = bridge_object_to_ref [[A]] : $Builtin.BridgeObject to $Class1
// CHECK-NEXT:    [[C:%.*]] = bridge_object_to_word [[A]] : $Builtin.BridgeObject to $Builtin.Word
// CHECK-NEXT:    return undef : $()
sil [fragile] @bridge_object : $@convention(thin) (@owned Class1, Builtin.Word) -> () {
entry(%x : $Class1, %w : $Builtin.Word):
  %a = ref_to_bridge_object %x : $Class1, %w : $Builtin.Word
  %b = bridge_object_to_ref %a : $Builtin.BridgeObject to $Class1
  %c = bridge_object_to_word %a : $Builtin.BridgeObject to $Builtin.Word
  return undef : $()
}

// CHECK-LABEL: sil {{.*}} [reabstraction_thunk] @a_reabstraction_thunk : $@convention(thin) () -> ()
sil [reabstraction_thunk] @a_reabstraction_thunk : $@convention(thin) () -> () {
  %1 = tuple()
  return %1 : $()
}
// CHECK-LABEL: sil {{.*}} [thunk] @a_regular_thunk : $@convention(thin) () -> () {
sil [thunk] @a_regular_thunk : $@convention(thin) () -> () {
  %1 = tuple()
  return %1 : $()
}

class Foo {
  subscript (x: Int, y: Int) -> Int32 { get set }
  var x: Int
  var y: Int
  init()
}

// CHECK-LABEL: sil [fragile] @_TFC3tmp3Foog9subscriptFT1xSi1ySi_Si : $@convention(method) (Int, Int, @guaranteed Foo) -> Int32
// CHECK_DECL-LABEL: sil [fragile] @_TFC3tmp3Foog9subscriptFT1xSi1ySi_Si : $@convention(method) (Int, Int, @guaranteed Foo) -> Int32{{$}}
sil [fragile] @_TFC3tmp3Foog9subscriptFT1xSi1ySi_Si : $@convention(method) (Int, Int, @guaranteed Foo) -> Int32 {
bb0(%0 : $Int, %1 : $Int, %2 : $Foo):
  %3 = tuple ()
  %4 = alloc_stack $Int  // var x               // users: %17, %6
  %5 = alloc_stack $Int  // var y               // users: %16, %7
  store %0 to %4 : $*Int
  store %1 to %5 : $*Int
  %8 = alloc_stack $Foo  // var self              // users: %15, %14, %9
  store %2 to %8 : $*Foo
  %10 = metatype $@thin Int.Type
  %12 = integer_literal $Builtin.Int32, 0         // user: %13
  %13 = struct $Int32 (%12 : $Builtin.Int32)      // user: %18
  destroy_addr %8 : $*Foo
  dealloc_stack %8 : $*Foo
  dealloc_stack %5 : $*Int
  dealloc_stack %4 : $*Int
  return %13 : $Int32
}

// CHECK-LABEL: sil [fragile] @_TFC3tmp3Foos9subscriptFT1xSi1ySi_Si : $@convention(method) (Int32, Int, Int, @guaranteed Foo) -> ()
// CHECK_DECL-LABEL: sil [fragile] @_TFC3tmp3Foos9subscriptFT1xSi1ySi_Si : $@convention(method) (Int32, Int, Int, @guaranteed Foo) -> (){{$}}
sil [fragile] @_TFC3tmp3Foos9subscriptFT1xSi1ySi_Si : $@convention(method) (Int32, Int, Int, @guaranteed Foo) -> () {
bb0(%0 : $Int32, %1 : $Int, %2 : $Int, %3 : $Foo):
  %4 = alloc_stack $Int32  // var value         // users: %16, %5
  store %0 to %4 : $*Int32
  %6 = alloc_stack $Int  // var x               // users: %15, %8
  %7 = alloc_stack $Int  // var y               // users: %14, %9
  store %1 to %6 : $*Int
  store %2 to %7 : $*Int
  %10 = alloc_stack $Foo  // var self             // users: %13, %12, %11
  store %3 to %10 : $*Foo
  destroy_addr %10 : $*Foo
  dealloc_stack %10 : $*Foo
  dealloc_stack %7 : $*Int
  dealloc_stack %6 : $*Int
  dealloc_stack %4 : $*Int32
  %17 = tuple ()                                  // user: %18
  return %17 : $()
}


// CHECK-LABEL: sil_vtable Foo {
// CHECK: #Foo.subscript!getter.1: _TFC3tmp3Foog9subscriptFT1xSi1ySi_Si
// CHECK: #Foo.subscript!setter.1: _TFC3tmp3Foos9subscriptFT1xSi1ySi_Si
// CHECK: }
// CHECK_DECL-LABEL: sil_vtable Foo {
// CHECK_DECL: #Foo.subscript!getter.1: _TFC3tmp3Foog9subscriptFT1xSi1ySi_Si
// CHECK_DECL: #Foo.subscript!setter.1: _TFC3tmp3Foos9subscriptFT1xSi1ySi_Si
// CHECK_DECL: }
sil_vtable Foo {
  #Foo.subscript!getter.1: _TFC3tmp3Foog9subscriptFT1xSi1ySi_Si
  #Foo.subscript!setter.1: _TFC3tmp3Foos9subscriptFT1xSi1ySi_Si
}

protocol AssocReqt {
  func requiredMethod()
}

struct ConformingAssoc : AssocReqt {
  func requiredMethod()
}

sil [fragile] @_TFV14witness_tables15ConformingAssoc14requiredMethodfS0_FT_T_ : $@convention(method) (@guaranteed ConformingAssoc) -> () {
bb0(%0 : $ConformingAssoc):
  debug_value %0 : $ConformingAssoc
  %2 = tuple ()
  return %2 : $()
}

sil [fragile] @_TTWV14witness_tables15ConformingAssocS_9AssocReqtS_FS1_14requiredMethodU_fRQPS1_FT_T_ : $@convention(witness_method) (@inout ConformingAssoc) -> () {
bb0(%0 : $*ConformingAssoc):
  %1 = load %0 : $*ConformingAssoc
  %2 = function_ref @_TFV14witness_tables15ConformingAssoc14requiredMethodfS0_FT_T_ : $@convention(method) (@guaranteed ConformingAssoc) -> ()
  %3 = apply %2(%1) : $@convention(method) (@guaranteed ConformingAssoc) -> ()
  return %3 : $()
}


// CHECK-LABEL: sil_witness_table public_external ConformingAssoc: AssocReqt module
// CHECK: #AssocReqt.requiredMethod!1: @_TTWV14witness_tables15ConformingAssocS_9AssocReqtS_FS1_14requiredMethodU_fRQPS1_FT_T_
// CHECK: }
sil_witness_table ConformingAssoc: AssocReqt module def_basic {
  method #AssocReqt.requiredMethod!1: @_TTWV14witness_tables15ConformingAssocS_9AssocReqtS_FS1_14requiredMethodU_fRQPS1_FT_T_
}

protocol AnyProtocol {
  associatedtype AssocType
  associatedtype AssocWithReqt : AssocReqt
  func assocTypesMethod(_ x: AssocType, y: AssocWithReqt)
  static func staticMethod(_ x: Self)
}
class SomeAssoc {
}
protocol InheritedProtocol1 : AnyProtocol {
  func inheritedMethod()
}
struct InheritedConformance : InheritedProtocol1 {
  typealias AssocType = SomeAssoc
  typealias AssocWithReqt = ConformingAssoc
  func assocTypesMethod(_ x: SomeAssoc, y: ConformingAssoc)
  static func staticMethod(_ x: InheritedConformance)
  func inheritedMethod()
}

// CHECK-LABEL: sil_witness_table public_external InheritedConformance: InheritedProtocol1 module
// CHECK: base_protocol AnyProtocol: InheritedConformance: AnyProtocol module
// CHECK: }
sil_witness_table InheritedConformance: InheritedProtocol1 module witness_tables {
  base_protocol AnyProtocol: InheritedConformance: AnyProtocol module witness_tables
}

// CHECK-LABEL: sil_witness_table public_external InheritedConformance: AnyProtocol module
// CHECK: associated_type AssocType: SomeAssoc
// CHECK: associated_type_protocol (AssocWithReqt: AssocReqt): ConformingAssoc: AssocReqt module
// CHECK: }
sil_witness_table InheritedConformance: AnyProtocol module witness_tables {
  associated_type AssocType: SomeAssoc
  associated_type_protocol (AssocWithReqt: AssocReqt): ConformingAssoc: AssocReqt module witness_tables
}

sil [fragile] [transparent] @_TF9def_basic13serialize_allFT_T_ : $@convention(thin) () -> () {
bb0:
  %0 = function_ref @_TFV18lazy_global_access4Type10staticPropSia_public : $@convention(thin) () -> Builtin.RawPointer
  %1 = function_ref @_TFV18lazy_global_access4Type10staticPropSia : $@convention(thin) () -> Builtin.RawPointer
  %2 = function_ref @test1 : $@convention(thin) () -> ()
  %4 = function_ref @test2 : $@convention(thin) (Int) -> ()
  %6 = function_ref @named_tuple : $@convention(thin) () -> (Builtin.Word, Builtin.Word)
  %9 = function_ref @return_int : $@convention(thin) (Int) -> Int
  %11 = function_ref @call_fn_pointer : $@convention(thin) (() -> Int) -> Int
  %13 = function_ref @return_constant : $@convention(thin) () -> Int
  %23 = function_ref @existentials : $@convention(thin) (@in P) -> ()
  %25 = function_ref @classes : $@convention(thin) () -> ()
  %27 = function_ref @_TF4todo18erasure_from_protoFT1xPS_8RuncibleS_8Bendable__PS0__ : $@convention(thin) (@in Bendable & Runcible) -> @out Runcible
  %29 = function_ref @_TF4todo18class_bound_methodFT1xPS_10ClassBound__T_ : $@convention(thin) (@owned ClassBound) -> ()
  %31 = function_ref @_TFV6struct5AlephCfMS0_FT1aCS_3Ref1bVS_3Val_S0_ : $@convention(thin) (Ref, Val, @thin Aleph.Type) -> Aleph
  %33 = function_ref @_TFV6struct5AlephCfMS0_FT_S0_ : $@convention(thin) (@thin Aleph.Type) -> Aleph
  %35 = function_ref @test_union_empty_case : $@convention(thin) () -> Beth
  %37 = function_ref @test_union_data_case : $@convention(thin) Int -> Beth
  %39 = function_ref @test_union_addr_empty_case : $@convention(thin) () -> @out Gimel
  %41 = function_ref @test_union_addr_data_case : $@convention(thin) (@in Q) -> @out Gimel
  %43 = function_ref @_TF5tuple5floatFT1xSf_T_ : $@convention(thin) (Float32) -> ()
  %45 = function_ref @_TF5tuple5tupleFT_TSiSf_ : $@convention(thin) () -> (Int, Float32)
  %47 = function_ref @_TF5tuple13tuple_elementFT1xTSiSf__T_ : $@convention(thin) (Int, Float32) -> ()
  %49 = function_ref @_TFC3ref1C3foofS0_FT1xSi_T_ : $@convention(method) (Int, @guaranteed M) -> ()
  %51 = function_ref @_TF4null3isaFT1bCS_1B_Sb : $@convention(thin) (B) -> Builtin.Int1
  %53 = function_ref @_TFSd31_convertFromBuiltinFloatLiteralfMSdFT5valueBf64__Sd : $@convention(thin) (Builtin.FPIEEE64, @thin Float64.Type) -> Float64
  %55 = function_ref @_TFSS32_convertFromBuiltinStringLiteralfMSSFT5valueBp17utf8CodeUnitCountBi64_7isASCIIBi1__SS : $@convention(thin) (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.Type) -> String
  %57 = function_ref @_TF7literal8literalsFT_T_ : $@convention(thin) () -> ()
  %59 = function_ref @_TF5index5gep64FT1pBp1iBi64__Bp : $@convention(thin) (Builtin.RawPointer, Builtin.Word) -> Builtin.RawPointer
  %60 = function_ref @global_code : $@convention(thin) () -> ()
  %63 = function_ref @test_class_metatype : $@convention(thin) (SomeClass, SomeSubclass) -> (@thick SomeClass.Type, @thick SomeClass.Type)
  %67 = function_ref @test_existential_metatype : $@convention(thin) (@in SomeProtocol) -> @thick SomeProtocol.Type
  %69 = function_ref @test_unreachable : $@convention(thin) () -> ()
  %71 = function_ref @test_unowned_retain : $@convention(thin) (SomeClass) -> ()
  %73 = function_ref @test_basic_block_arguments : $@convention(thin) (Builtin.Int1) -> Builtin.Word
  %75 = function_ref @test_cond_branch_basic_block_args : $@convention(thin) (Int, Builtin.Int1) -> Int

  %81 = function_ref @test_builtin_func_ref : $@convention(thin) (Builtin.Int1, Builtin.Int1) -> Builtin.Int1
  %83 = function_ref @test_dealloc_ref : $@convention(thin) () -> ()
  %84 = function_ref @test_dealloc_partial_ref : $@convention(thin) () -> ()
  %85 = function_ref @test_dealloc_box : $@convention(thin) () -> ()
  %86 = function_ref @test_stack_flag : $@convention(thin) () -> ()
  %87 = function_ref @closure_test : $@convention(thin) () -> ()
  %97 = function_ref @test_switch_union : $@convention(thin) (MaybePair) -> ()
  %99 = function_ref @test_switch_union_addr : $@convention(thin) (@in MaybeAddressOnlyPair) -> ()
  %101 = function_ref @test_switch_value : $@convention(thin) (Builtin.Word) -> ()
  %103 = function_ref @test_init_existential : $@convention(thin) (Spoon) -> @out Bendable
  %105 = function_ref @test_existential_ref : $@convention(thin) (ConcreteClass) -> ClassP

  %107 = function_ref @test_assign : $@convention(thin) (Int, @inout Int) -> ()
  %109 = function_ref @test_transparent : $@convention(thin) () -> ()
  %110 = function_ref @test_thunk : $@convention(thin) () -> ()
  %130 = function_ref @noinline_callee : $@convention(thin) () -> Int
  %132 = function_ref @always_inline_callee : $@convention(thin) () -> Int
  %131 = function_ref @test_semantics : $@convention(thin) () -> ()
  %111 = function_ref @test_partial_apply : $@convention(thin) Float32 -> @callee_owned Int -> ()
  %113 = function_ref @test_dynamic_lookup_br : $@convention(thin) (AnyObject) -> ()
  %115 = function_ref @test_mark_fn_escape : $@convention(thin) () -> ()
  %117 = function_ref @test_copy_release_value : $@convention(thin) (X) -> (X)
  %118 = function_ref @test_set_deallocating : $@convention(thin) (X) -> (X)
  %119 = function_ref @test_pointer_to_address : $@convention(thin) (Builtin.RawPointer, X) -> ()
  %120 = function_ref @test_bind_memory : $@convention(thin) (Builtin.RawPointer, Builtin.Word) -> ()
  %121 = function_ref @cond_fail_test : $@convention(thin) Builtin.Int1 -> ()

  %124 = function_ref @block_storage_type : $@convention(thin) Int -> @convention(block) () -> ()
  %127 = function_ref @bitcasts : $@convention(thin) (@owned Class1) -> @owned (Class2, Int)
  %133 = function_ref @test_try_apply : $@convention(thin) (@convention(thin) () -> @error Error) -> @error Error
  %135 = function_ref @test_try_nothrow : $@convention(thin) (@convention(thin) () -> @error Error) -> ()
  %134 = function_ref @box_type : $@convention(thin) (@box Int, Int) -> ()
  %140 = function_ref @test_forward_ref : $@convention(thin) (UInt8, UInt8) -> UInt8
  %141 = function_ref @partial_apply : $@convention(thin) (@convention(thin) (Int) -> @out Int, Int) -> Int
  %142 = function_ref @partial_apply_with_closure : $@convention(thin) (@owned @callee_owned () -> Bool, @owned String, UnsafePointer<Int8>, Int64) -> ()
  %143 = function_ref @extract_generic_struct : $@convention(thin) GenericStruct<Int64> -> Int64
  %148 = function_ref @select_enum : $@convention(thin) (@in Beth) -> ()
  %149 = function_ref @existential_box : $@convention(thin) (SomeError) -> ()
  %150 = function_ref @bridge_object : $@convention(thin) (@owned Class1, Builtin.Word) -> ()
  %151 = function_ref @a_reabstraction_thunk: $@convention(thin) () -> ()
  %152 = function_ref @a_regular_thunk: $@convention(thin) () -> ()

  %r = tuple ()
  return %r : $()
}

